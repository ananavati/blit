package com.blit.elements{	import com.blit.Globals;	import com.blit.layers.RenderLayer;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.events.EventDispatcher;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.getQualifiedClassName;
	/**	 * The PixelSprite class is the base class for all classes that	 *  can be added to a render layer and be rendered.	 * 	 * The PixelSprite class is very similar to the Sprite class but, in bitmap form.	 * Rotation, alpha, and scale are currently not supported.	 * 	 */	public dynamic class PixelSprite extends EventDispatcher	{		/**		 * @private		 */		protected const ZERO_POINT:Point = new Point();				/**		 * @private		 */		protected var mLayer:RenderLayer;		/**		 * @private		 */		protected var mCollisionRect:Rectangle = new Rectangle();				/**		 * The horizontal position in pixels of the PixelSprite instance.		 */		public var x:Number 	= 0;		/**		 * The vertical position in pixels of the PixelSprite instance.		 */		public var y:Number 	= 0;		/**		 * The width in pixels of the PixelSprite instance.		 */		public var width:int 	= 0;		/**		 * The height in pixels of the PixelSprite instance.		 */		public var height:int 	= 0;		/**		 * The BitmapData object that will be rendered to the RenderLayer this object has been added to.		 */		public var bitmapData:BitmapData;		/**		 * The BitmapData object rect property.		 */		public var rect:Rectangle;				/**		 * track the changes of this pixelsprite instance 		 */				private var isUpdated:Boolean;					/**		 * Creates a PixelSprite instance.		 * 		 * Parses the supplied DisplayObject and converts the first frame of animation to a virtual frame.		 * The DisplayObject is drawn to a bitmapData object with the width and height of the 		 * DisplayObject defining the width and height of the BitmapData object.		 * 		 * @param displayObject The DisplayObject instance to convert into a PixelSprite object.		 */		public function PixelSprite( displayObject:DisplayObject )		{  			parseClip( displayObject );						rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;						isUpdated = true;		}				/**		 * @private		 * Parses the supplied DisplayObject and converts each frame of animation to a virtual frame.		 * @param displayObject The displayObject to convert.		 */		protected function parseClip( displayObject:DisplayObject ):void		{			var id:String = getQualifiedClassName( displayObject ) + "_" + 1;							// check if it is already in the collection (except for bitmaps)			if ( Globals.bmdCollection.lookup( id ) && !displayObject is Bitmap)			{				bitmapData = Globals.bmdCollection.mBmpDataCollection[id];			}			else			{				// create a new bitmapData object to draw on				var bmd:BitmapData = new BitmapData( displayObject.width, displayObject.height, true, 0x0 );								//	Does the Display Object have any scaling or rotation applied to it?				if (displayObject.scaleX != 1 || displayObject.scaleY != 1 || displayObject.rotation != 0)				{					var matrix:Matrix = new Matrix();										matrix.scale(displayObject.scaleX, displayObject.scaleY);										bmd.draw( displayObject, matrix );				}				else				{					bmd.draw( displayObject );				}								// add the bitmapData to the collection				bitmapData = Globals.bmdCollection.addBitmapData( id, bmd );			}		}				/**		 * @private		 */		public function set layer( value:RenderLayer ):void		{			mLayer = value;		}				/**		 * The depth or z-order of the PixelSprite instance.		 */		public function get depth():int		{			return mLayer.getDepth( this );			}				/**		 * Performs a pixel-level collision check against the supplied PixelSprite object.		 *  		 * This is a shape based collision test versus the standard DisplayObject bounding box <code>hitTestObject</code>.		 * The collision check compares the alpha value of each pixel. 		 * 		 * @param object The PixelSprite instance to test against.		 * @return Returns a boolean value indicating if a collision occured.		 * @example 		 * <code>		 * if ( obj1.getCollision( obj2 ) )		 * {		 * 		trace("collision occured");		 * }		 * </code>		 */		public function getCollision( object:PixelSprite ):Boolean		{			var value:Boolean = false;						if ( bitmapData.hitTest( new Point(x, y), 1, object.bitmapData, new Point( object.x, object.y), 1 ) )			{				value = true;			}						return value;		}				public function hasUpdated():Boolean		{			return isUpdated;		}				public function reset():void		{			isUpdated = false;			}				/**		 * Checks if the supplied point is inside of the PixelSprite object.		 * 		 * This method is useful for mouse detection where the point is the mouse x and y properties.		 * 		 * @param point The Point to test against.		 * @return A boolean value indicating if a collision occured.		 */		public function getCollisionPoint( point:Point ):Boolean		{			var value:Boolean = false;						mCollisionRect.x = (x + Globals.camera2D.basePoint.x) /** mLayer.parrallax*/;			mCollisionRect.y = (y + Globals.camera2D.basePoint.y) /** mLayer.parrallax*/;						mCollisionRect.width = width;			mCollisionRect.height = height;						if ( mCollisionRect.containsPoint( point ) )			{				value = true;			}						return value;		}				/**		 * Removes the PixelSprite from the RenderLayer it is registered to.		 * The dispose method also clears the internal data making it available for Garbage Collection.		 * All external refferences should be set to null as well to ensure it will be available for Garbage Collection.		 */		public function dispose():void		{			bitmapData.dispose();			bitmapData = null;			mLayer.removeChild( this );		}				/**		 * @private		 */		public function update():void 		{			rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;						isUpdated = true;		}		}}